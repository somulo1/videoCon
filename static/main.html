<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Chat</title>
    <style>
       /* Reset basic elements */
body, html {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
}

/* Overall page layout */
body {
    background-color: #f4f4f9;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    flex-direction: column;
    padding: 20px;
}

/* Center the login section */
#loginSection {
    text-align: center;
    padding: 20px;
    border-radius: 8px;
    background-color: white;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

/* Hide elements with class 'hidden' */
.hidden {
    display: none;
}

/* Video container layout */
#localVideo {
    width: 300px;
    height: 200px;
    border: 2px solid black;
    margin-bottom: 20px;
}

/* Container for remote video elements */
#remoteVideosContainer {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

/* Style for each video element */
video {
    width: 300px;
    height: 200px;
    border: 2px solid black;
}

/* Chat container */
#chatContainer {
    margin-top: 20px;
    width: 100%;
    max-width: 500px;
    background-color: white;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

/* Chat messages container */
#chatMessages {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 10px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    background-color: #fff;
}

/* Style for individual chat messages */
.messageWrapper {
    margin-bottom: 10px;
    display: flex;
    flex-direction: column;
}

.messageWrapper.sent .message {
    background-color: #f1f1f1;
    border-radius: 8px;
    padding: 5px;
    max-width: 80%;
    align-self: flex-end;
}

.messageWrapper.received .message {
    background-color: #d1f7d1;
    border-radius: 8px;
    padding: 5px;
    max-width: 80%;
    align-self: flex-start;
}

.nameTag {
    font-weight: bold;
    color: #333;
    font-size: 0.9em;
}

.message {
    font-size: 1em;
    color: #333;
}

/* Chat input and button styles */
#messageInput {
    width: 80%;
    padding: 5px;
    margin-bottom: 10px;
    border-radius: 4px;
    border: 1px solid #ccc;
}

#sendBtn {
    padding: 5px 10px;
    border-radius: 4px;
    background-color: #2196F3;
    color: white;
    border: none;
    cursor: pointer;
}

#sendBtn:hover {
    background-color: #0b7dda;
}

/* Screen sharing button */
#screenShareBtn {
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#screenShareBtn:hover {
    background-color: #45a049;
}

/* Login button style */
#loginBtn {
    padding: 10px 20px;
    background-color: #2196F3;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#loginBtn:hover {
    background-color: #0b7dda;
}

#username {
    padding: 10px;
    width: 80%;
    margin-bottom: 20px;
    border-radius: 4px;
    border: 1px solid #ccc;
}

/* Styling for the user info after login */
h2 {
    font-size: 1.5em;
    color: #333;
}

    </style>
</head>
<body>
    <!-- Login Section -->
    <div id="loginSection">
        <h2>Enter your username</h2>
        <input type="text" id="username" placeholder="Enter username" />
        <button id="loginBtn">Login</button>
    </div>

    <!-- Call Section -->
    <div id="callSection" class="hidden">
        <h2>Welcome, <span id="displayUsername"></span></h2>
        <video id="localVideo" autoplay muted></video>
        <div id="remoteVideosContainer"></div>
        
        <!-- Chat Section -->
        <div id="chatContainer">
            <div id="chatMessages"></div>
            <input type="text" id="messageInput" placeholder="Type a message" />
            <button id="sendBtn">Send</button>
        </div>

        <button id="screenShareBtn">Start Screen Sharing</button>
    </div>

    <script>
        let localStream, peerConnections = {}, dataChannels = {};
        let screenSharingStream = null, screenSharingActive = false;
        const remoteVideosContainer = document.getElementById('remoteVideosContainer');
        const localVideo = document.getElementById('localVideo');
        const screenShareBtn = document.getElementById('screenShareBtn');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const chatMessages = document.getElementById('chatMessages');
        const loginSection = document.getElementById('loginSection');
        const callSection = document.getElementById('callSection');
        const usernameInput = document.getElementById('username');
        const displayUsername = document.getElementById('displayUsername');
        const socket = new WebSocket('wss://your-signaling-server.com');  // Replace with your WebSocket signaling server URL

        // Ice Servers configuration
        const iceServers = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        socket.onopen = () => {
            console.log('Connected to signaling server');
        };

        socket.onmessage = (message) => {
            const data = JSON.parse(message.data);
            const { type, payload } = data;
            switch (type) {
                case 'offer': handleOffer(payload); break;
                case 'answer': handleAnswer(payload); break;
                case 'ice-candidate': handleICECandidate(payload); break;
                case 'message': receiveMessage(payload.message, payload.senderId); break;
            }
        };

        function sendSignalingMessage(type, payload) {
            socket.send(JSON.stringify({ type, payload }));
        }

        function createPeerConnection(peerId) {
            const peerConnection = new RTCPeerConnection(iceServers);

            // When remote stream is added, display it in a new video element
            peerConnection.ontrack = (event) => {
                const remoteVideoElement = document.createElement('video');
                remoteVideoElement.srcObject = event.streams[0];
                remoteVideoElement.autoplay = true;
                remoteVideosContainer.appendChild(remoteVideoElement);
            };

            // Add local stream tracks to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Create a data channel for messaging
            const dataChannel = peerConnection.createDataChannel('chat');
            dataChannel.onmessage = (event) => {
                receiveMessage(event.data, peerId);
            };

            // Store peer connection and data channel
            peerConnections[peerId] = peerConnection;
            dataChannels[peerId] = dataChannel;

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendICECandidate(peerId, event.candidate);
                }
            };

            return peerConnection;
        }

        function sendMessage(peerId, message) {
            const channel = dataChannels[peerId];
            if (channel) {
                channel.send(message);
                appendMessageToChat(message, 'sent');
            }
        }

        function receiveMessage(message, senderId) {
            appendMessageToChat(message, 'received', senderId);
        }

        function appendMessageToChat(message, type, senderId) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('messageWrapper', type);
            messageDiv.innerHTML = type === 'received'
                ? `<div class="nameTag">${senderId}</div><div class="message">${message}</div>`
                : `<div class="message">${message}</div>`;
            chatMessages.appendChild(messageDiv);
        }

        async function startVideo() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices.', error);
            }
        }

        async function setupCall() {
            await startVideo();
        }

        // Handle incoming offer
        async function handleOffer(offer) {
            const peerId = offer.senderId;
            const peerConnection = createPeerConnection(peerId);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer.sdp));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            sendSignalingMessage('answer', { peerId, sdp: answer });
        }

        // Handle incoming answer
        function handleAnswer(answer) {
            const peerId = answer.senderId;
            peerConnections[peerId].setRemoteDescription(new RTCSessionDescription(answer.sdp));
        }

        // Handle ICE candidates
        function handleICECandidate(candidate) {
            const peerId = candidate.senderId;
            peerConnections[peerId].addIceCandidate(new RTCIceCandidate(candidate.candidate));
        }

        // Send ICE candidates to other peers
        function sendICECandidate(peerId, candidate) {
            sendSignalingMessage('ice-candidate', { peerId, candidate });
        }

        // Start screen sharing
        async function toggleScreenSharing() {
            if (screenSharingActive) {
                const tracks = screenSharingStream.getTracks();
                tracks.forEach(track => track.stop());
                screenSharingActive = false;
                screenShareBtn.textContent = "Start Screen Sharing";
                screenSharingStream = null;
            } else {
                try {
                    screenSharingStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                    screenSharingStream.getTracks().forEach(track => localStream.addTrack(track));
                    screenSharingActive = true;
                    screenShareBtn.textContent = "Stop Screen Sharing";
                } catch (error) {
                    console.error('Error sharing screen:', error);
                }
            }
        }

        // Login button click handler
        document.getElementById('loginBtn').onclick = () => {
            const username = usernameInput.value;
            if (username) {
                loginSection.classList.add('hidden');
                callSection.classList.remove('hidden');
                displayUsername.textContent = username;
                setupCall();
            }
        };

        // Send message button click handler
        sendBtn.onclick = () => {
            const message = messageInput.value;
            if (message) {
                Object.keys(peerConnections).forEach(peerId => {
                    sendMessage(peerId, message);
                });
                messageInput.value = '';
            }
        };

        // Handle screen sharing button click
        screenShareBtn.onclick = toggleScreenSharing;
    </script>
</body>
</html>
